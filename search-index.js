var searchIndex = new Map(JSON.parse('[\
["boba",{"doc":"This crate provides an implementation of a Bubble Babble …","t":"PPGPPPPPNNNNNHHNNNNNNNNNNNN","n":["ChecksumMismatch","Corrupted","DecodeError","ExpectedConsonant","ExpectedVowel","InvalidByte","MalformedHeader","MalformedTrailer","borrow","borrow_mut","clone","clone_into","cmp","decode","encode","eq","fmt","fmt","from","hash","into","partial_cmp","to_owned","to_string","try_from","try_into","type_id"],"q":[[0,"boba"],[27,"core::cmp"],[28,"alloc::vec"],[29,"core::result"],[30,"core::convert"],[31,"alloc::string"],[32,"core::fmt"],[33,"core::fmt"],[34,"core::option"],[35,"core::any"]],"d":["Checksum mismatch when decoding input.","Corrupted input caused a decoding failure.","Decoding errors from <code>boba::decode</code>.","Expected to process a consonant from the encoding …","Expected to process a vowel from the encoding alphabet, …","Input contained a byte not in the encoding alphabet at …","Input was missing a leading <code>x</code> header.","Input was missing a final <code>x</code> trailer.","","","","","","Decode Bubble Babble-encoded byte slice to a <code>Vec&lt;u8&gt;</code>.","Encode a byte slice with the Bubble Babble encoding to a …","","","","Returns the argument unchanged.","","Calls <code>U::from(self)</code>.","","","","","",""],"i":[1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1],"f":"````````{ce{}{}}0{bb}{{ce}d{}{}}{{bb}f}{c{{l{{j{h}}b}}}{{A`{{n{h}}}}}}{cAb{{A`{{n{h}}}}}}{{bb}Ad}{{bAf}Ah}0{cc{}}{{bc}dAj}9{{bb}{{Al{f}}}}:{cAb{}}{c{{l{e}}}{}{}}0{cAn{}}","c":[],"p":[[6,"DecodeError",0],[1,"unit"],[6,"Ordering",27],[1,"u8"],[5,"Vec",28],[6,"Result",29],[1,"slice"],[10,"AsRef",30],[5,"String",31],[1,"bool"],[5,"Formatter",32],[8,"Result",32],[10,"Hasher",33],[6,"Option",34],[5,"TypeId",35]],"b":[[16,"impl-Display-for-DecodeError"],[17,"impl-Debug-for-DecodeError"]]}]\
]'));
if (typeof exports !== 'undefined') exports.searchIndex = searchIndex;
else if (window.initSearch) window.initSearch(searchIndex);
